/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef mytoolbox_TYPES_H
#define mytoolbox_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "mybase_types.h"


namespace mytoolbox {

enum PointType {
  CITY = 0,
  VILLAGE = 1,
  LAKE = 2,
  MOUNTAIN = 3,
  LANDMARK = 4
};

extern const std::map<int, const char*> _PointType_VALUES_TO_NAMES;

typedef int16_t distance;

class Point;

class CoordsOutOfRange;

class NoValidRegex;

class InvalidInputString;

typedef struct _Point__isset {
  _Point__isset() : latitude(false), longitude(false), name(false), type(false) {}
  bool latitude :1;
  bool longitude :1;
  bool name :1;
  bool type :1;
} _Point__isset;

class Point {
 public:

  Point(const Point&);
  Point(Point&&);
  Point& operator=(const Point&);
  Point& operator=(Point&&);
  Point() : latitude(0), longitude(0), name(), type((PointType)0) {
  }

  virtual ~Point() throw();
  double latitude;
  double longitude;
  std::string name;
  PointType type;

  _Point__isset __isset;

  void __set_latitude(const double val);

  void __set_longitude(const double val);

  void __set_name(const std::string& val);

  void __set_type(const PointType val);

  bool operator == (const Point & rhs) const
  {
    if (!(latitude == rhs.latitude))
      return false;
    if (!(longitude == rhs.longitude))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const Point &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Point & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Point &a, Point &b);

inline std::ostream& operator<<(std::ostream& out, const Point& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CoordsOutOfRange__isset {
  _CoordsOutOfRange__isset() : description(false) {}
  bool description :1;
} _CoordsOutOfRange__isset;

class CoordsOutOfRange : public ::apache::thrift::TException {
 public:

  CoordsOutOfRange(const CoordsOutOfRange&);
  CoordsOutOfRange(CoordsOutOfRange&&);
  CoordsOutOfRange& operator=(const CoordsOutOfRange&);
  CoordsOutOfRange& operator=(CoordsOutOfRange&&);
  CoordsOutOfRange() : description() {
  }

  virtual ~CoordsOutOfRange() throw();
  std::string description;

  _CoordsOutOfRange__isset __isset;

  void __set_description(const std::string& val);

  bool operator == (const CoordsOutOfRange & rhs) const
  {
    if (!(description == rhs.description))
      return false;
    return true;
  }
  bool operator != (const CoordsOutOfRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoordsOutOfRange & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(CoordsOutOfRange &a, CoordsOutOfRange &b);

inline std::ostream& operator<<(std::ostream& out, const CoordsOutOfRange& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NoValidRegex__isset {
  _NoValidRegex__isset() : description(false) {}
  bool description :1;
} _NoValidRegex__isset;

class NoValidRegex : public ::apache::thrift::TException {
 public:

  NoValidRegex(const NoValidRegex&);
  NoValidRegex(NoValidRegex&&);
  NoValidRegex& operator=(const NoValidRegex&);
  NoValidRegex& operator=(NoValidRegex&&);
  NoValidRegex() : description() {
  }

  virtual ~NoValidRegex() throw();
  std::string description;

  _NoValidRegex__isset __isset;

  void __set_description(const std::string& val);

  bool operator == (const NoValidRegex & rhs) const
  {
    if (!(description == rhs.description))
      return false;
    return true;
  }
  bool operator != (const NoValidRegex &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoValidRegex & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(NoValidRegex &a, NoValidRegex &b);

inline std::ostream& operator<<(std::ostream& out, const NoValidRegex& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _InvalidInputString__isset {
  _InvalidInputString__isset() : description(false) {}
  bool description :1;
} _InvalidInputString__isset;

class InvalidInputString : public ::apache::thrift::TException {
 public:

  InvalidInputString(const InvalidInputString&);
  InvalidInputString(InvalidInputString&&);
  InvalidInputString& operator=(const InvalidInputString&);
  InvalidInputString& operator=(InvalidInputString&&);
  InvalidInputString() : description() {
  }

  virtual ~InvalidInputString() throw();
  std::string description;

  _InvalidInputString__isset __isset;

  void __set_description(const std::string& val);

  bool operator == (const InvalidInputString & rhs) const
  {
    if (!(description == rhs.description))
      return false;
    return true;
  }
  bool operator != (const InvalidInputString &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidInputString & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(InvalidInputString &a, InvalidInputString &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidInputString& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#include "mytoolbox_types.tcc"

#endif
