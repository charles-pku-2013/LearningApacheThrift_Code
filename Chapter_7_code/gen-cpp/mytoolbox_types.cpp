/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "mytoolbox_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace mytoolbox {

int _kPointTypeValues[] = {
  CITY,
  VILLAGE,
  LAKE,
  MOUNTAIN,
  LANDMARK
};
const char* _kPointTypeNames[] = {
  "CITY",
  "VILLAGE",
  "LAKE",
  "MOUNTAIN",
  "LANDMARK"
};
const std::map<int, const char*> _PointType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kPointTypeValues, _kPointTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Point::~Point() throw() {
}


void Point::__set_latitude(const double val) {
  this->latitude = val;
}

void Point::__set_longitude(const double val) {
  this->longitude = val;
}

void Point::__set_name(const std::string& val) {
  this->name = val;
}

void Point::__set_type(const PointType val) {
  this->type = val;
}

void swap(Point &a, Point &b) {
  using ::std::swap;
  swap(a.latitude, b.latitude);
  swap(a.longitude, b.longitude);
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

Point::Point(const Point& other1) {
  latitude = other1.latitude;
  longitude = other1.longitude;
  name = other1.name;
  type = other1.type;
  __isset = other1.__isset;
}
Point::Point( Point&& other2) {
  latitude = std::move(other2.latitude);
  longitude = std::move(other2.longitude);
  name = std::move(other2.name);
  type = std::move(other2.type);
  __isset = std::move(other2.__isset);
}
Point& Point::operator=(const Point& other3) {
  latitude = other3.latitude;
  longitude = other3.longitude;
  name = other3.name;
  type = other3.type;
  __isset = other3.__isset;
  return *this;
}
Point& Point::operator=(Point&& other4) {
  latitude = std::move(other4.latitude);
  longitude = std::move(other4.longitude);
  name = std::move(other4.name);
  type = std::move(other4.type);
  __isset = std::move(other4.__isset);
  return *this;
}
void Point::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Point(";
  out << "latitude=" << to_string(latitude);
  out << ", " << "longitude=" << to_string(longitude);
  out << ", " << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ")";
}


CoordsOutOfRange::~CoordsOutOfRange() throw() {
}


void CoordsOutOfRange::__set_description(const std::string& val) {
  this->description = val;
}

void swap(CoordsOutOfRange &a, CoordsOutOfRange &b) {
  using ::std::swap;
  swap(a.description, b.description);
  swap(a.__isset, b.__isset);
}

CoordsOutOfRange::CoordsOutOfRange(const CoordsOutOfRange& other5) : TException() {
  description = other5.description;
  __isset = other5.__isset;
}
CoordsOutOfRange::CoordsOutOfRange( CoordsOutOfRange&& other6) : TException() {
  description = std::move(other6.description);
  __isset = std::move(other6.__isset);
}
CoordsOutOfRange& CoordsOutOfRange::operator=(const CoordsOutOfRange& other7) {
  description = other7.description;
  __isset = other7.__isset;
  return *this;
}
CoordsOutOfRange& CoordsOutOfRange::operator=(CoordsOutOfRange&& other8) {
  description = std::move(other8.description);
  __isset = std::move(other8.__isset);
  return *this;
}
void CoordsOutOfRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CoordsOutOfRange(";
  out << "description=" << to_string(description);
  out << ")";
}

const char* CoordsOutOfRange::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: CoordsOutOfRange";
  }
}


NoValidRegex::~NoValidRegex() throw() {
}


void NoValidRegex::__set_description(const std::string& val) {
  this->description = val;
}

void swap(NoValidRegex &a, NoValidRegex &b) {
  using ::std::swap;
  swap(a.description, b.description);
  swap(a.__isset, b.__isset);
}

NoValidRegex::NoValidRegex(const NoValidRegex& other9) : TException() {
  description = other9.description;
  __isset = other9.__isset;
}
NoValidRegex::NoValidRegex( NoValidRegex&& other10) : TException() {
  description = std::move(other10.description);
  __isset = std::move(other10.__isset);
}
NoValidRegex& NoValidRegex::operator=(const NoValidRegex& other11) {
  description = other11.description;
  __isset = other11.__isset;
  return *this;
}
NoValidRegex& NoValidRegex::operator=(NoValidRegex&& other12) {
  description = std::move(other12.description);
  __isset = std::move(other12.__isset);
  return *this;
}
void NoValidRegex::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoValidRegex(";
  out << "description=" << to_string(description);
  out << ")";
}

const char* NoValidRegex::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoValidRegex";
  }
}


InvalidInputString::~InvalidInputString() throw() {
}


void InvalidInputString::__set_description(const std::string& val) {
  this->description = val;
}

void swap(InvalidInputString &a, InvalidInputString &b) {
  using ::std::swap;
  swap(a.description, b.description);
  swap(a.__isset, b.__isset);
}

InvalidInputString::InvalidInputString(const InvalidInputString& other13) : TException() {
  description = other13.description;
  __isset = other13.__isset;
}
InvalidInputString::InvalidInputString( InvalidInputString&& other14) : TException() {
  description = std::move(other14.description);
  __isset = std::move(other14.__isset);
}
InvalidInputString& InvalidInputString::operator=(const InvalidInputString& other15) {
  description = other15.description;
  __isset = other15.__isset;
  return *this;
}
InvalidInputString& InvalidInputString::operator=(InvalidInputString&& other16) {
  description = std::move(other16.description);
  __isset = std::move(other16.__isset);
  return *this;
}
void InvalidInputString::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidInputString(";
  out << "description=" << to_string(description);
  out << ")";
}

const char* InvalidInputString::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidInputString";
  }
}

} // namespace
